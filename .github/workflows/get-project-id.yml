name: Kanban Slack Update

on:
  push:
    branches:
      - main  # Adjust the branch name as needed
  workflow_dispatch:  # Allows manual triggering

env:
  PAT: ${{ secrets.PAT }}
  TEAM_TO_CHANNEL: "{ \"s24-4pm-1\": \"C071HLX6DMK\", \"s24-4pm-2\": \"C06592UPS91\" }"
  TEAM: ${{ github.repository }}
  ORG_NAME: "brownfield-team"  # Replace with your GitHub organization name

jobs:
  get-team-name:
    name: Get Team Name
    runs-on: ubuntu-latest
    outputs:
      team: ${{ steps.find_team.outputs.team }}
    steps:
      - name: Extract Team Name from Repo
        id: find_team
        run: |
          REPO=${{ github.repository }}
          TEAM_NAME="${REPO: -9}"
          echo "::set-output name=team::${TEAM_NAME}"
  get-project-id:
    name: Find Last Updated Project ID for Team
    runs-on: ubuntu-latest
    needs: get-team-name
    outputs:
      project_id: ${{ steps.find_project.outputs.project_id }}
    steps:
      - name: Fetch Project ID
        id: find_project
        shell: pwsh
        run: |
          $query = '{organization(login:"${{ env.ORG_NAME }}"){projectsV2(first:100){nodes{id,title,updatedAt}}}}'
          $headers = @{
              Authorization = "Bearer ${{ secrets.PAT }}"
              "Content-Type" = "application/json"
          }
          $body = @{ query = $query } | ConvertTo-Json
          $response = Invoke-WebRequest -Uri "https://api.github.com/graphql" -Method Post -Headers $headers -Body $body
          Write-Host "Projects JSON Output: $($response.Content)"
          
          $projectID = ($response.Content | ConvertFrom-Json).data.organization.projectsV2.nodes | Where-Object { $_.title -like "*${{ needs.get-team-name.outputs.team }}*" } | Select-Object -First 1 -ExpandProperty id
          
          if (-not $projectID) {
              Write-Host "No project found for team ${{ needs.get-team-name.outputs.team }}."
              exit 1
          }
          
          Write-Host "Found Project ID: $projectID"
          echo "::set-output name=project_id::$projectID"
  get-project-data:
    name: Output GraphQL Query Result
    runs-on: ubuntu-latest
    needs: get-project-id
    outputs:
      project_data: ${{ steps.output_query.outputs.project_data }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v2

      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '14'

      - name: Output GraphQL Query Result
        id: output_query
        shell: pwsh
        env:
          project_id: ${{ needs.get-project-id.outputs.project_id }}
          PAT: ${{ secrets.PAT }}
        run: |
          $PROJECT_ID = $env:project_id; $TOKEN = $env:PAT; $query = "{ node(id: `"$PROJECT_ID`") { ... on ProjectV2 { items(first: 100) { nodes { id fieldValues(first: 100) { nodes { ... on ProjectV2ItemFieldSingleSelectValue { field { ... on ProjectV2Field { name } } name } ... on ProjectV2ItemFieldTextValue { field { ... on ProjectV2Field { name } } text } } } content { ... on Issue { title assignees(first: 10) { nodes { login } } } ... on PullRequest { title assignees(first: 10) { nodes { login } } } } } } } } } }"; $headers = @{ Authorization = "Bearer $TOKEN"; "Content-Type" = "application/json" }; $body = @{ query = $query } | ConvertTo-Json; $response = Invoke-WebRequest -Uri "https://api.github.com/graphql" -Method Post -Headers $headers -Body $body; Write-Host $response.Content; echo "::set-output name=project_data::$($response.Content)"
  count_issues:
    name: Count Issues by Column and Assignee
    runs-on: ubuntu-latest
    needs: get-project-data
    outputs:
      issue_counts: ${{ steps.count_issues.outputs.issue_counts }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v2

      - name: Set up Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '14'

      - name: Count Issues by Column and Assignee
        id: count_issues
        shell: pwsh
        env:
          project_data: ${{ needs.get-project-data.outputs.project_data }}
        run: |
          Write-Host "Starting issue count process"
          $data = $env:project_data | ConvertFrom-Json
          Write-Host "Project Data JSON: $($data | ConvertTo-Json -Depth 10)"
          $issueCounts = @{}
          foreach ($item in $data.data.node.items.nodes) {
            Write-Host "Processing item: $($item.id)"
            $columnField = $item.fieldValues.nodes | Where-Object { $_.name -eq "Status" -or $_.name -eq "testing" -or $_.name -eq "Done" -or $_.name -eq "In Progress" -or $_.name -eq "Todo" }
            if ($null -ne $columnField) {
              Write-Host "Found column field: $($columnField | ConvertTo-Json -Depth 10)"
              $column = $columnField.name
              Write-Host "Processing column: $column"
              if ($null -ne $column) {
                $assignees = $item.content.assignees.nodes | Select-Object -ExpandProperty login
                foreach ($assignee in $assignees) {
                  Write-Host "Processing assignee: $assignee"
                  if (-not $issueCounts.ContainsKey($column)) {
                    $issueCounts[$column] = @{}
                  }
                  if (-not $issueCounts[$column].ContainsKey($assignee)) {
                    $issueCounts[$column][$assignee] = 0
                  }
                  $issueCounts[$column][$assignee]++
                }
              }
            } else {
              Write-Host "No column field found for item: $($item.id)"
            }
          }
          foreach ($column in $issueCounts.Keys) {
            Write-Host "Column: $column"
            foreach ($assignee in $issueCounts[$column].Keys) {
              Write-Host "  Assignee: $assignee, Count: $($issueCounts[$column][$assignee])"
            }
          }
          $issueCountsJson = $issueCounts | ConvertTo-Json -Depth 10
          Write-Host "Issue Counts JSON: $issueCountsJson"  # Debugging: Output the issue counts JSON
          $issueCountsJson | Out-File issue_counts.json
          echo "::set-output name=issue_counts::$issueCountsJson"
          Write-Host "Issue count process completed"

      - name: Upload issue counts
        uses: actions/upload-artifact@v3
        with:
          name: issue_counts
          path: issue_counts.json

  generate-ascii-table:
    name: Generate ASCII Table
    runs-on: ubuntu-latest
    needs: count_issues
    steps:
      - name: Download issue counts
        uses: actions/download-artifact@v3
        with:
          name: issue_counts

      - name: Generate ASCII Table
        id: generate_table
        shell: pwsh
        run: |
          $issueCounts = Get-Content issue_counts.json
          Write-Host "ISSUE_COUNTS: $issueCounts"  # Debugging: Output the ISSUE_COUNTS variable
          if (-not $issueCounts) {
            Write-Host "ISSUE_COUNTS is empty or not set"
            exit 1
          }
          Write-Host "Attempting to convert ISSUE_COUNTS to Hashtable"
          $issueCounts = $issueCounts | ConvertFrom-Json
          Write-Host "Converted ISSUE_COUNTS to Hashtable"

          # Debugging: Output the converted Hashtable
          Write-Host "Converted ISSUE_COUNTS Hashtable: $($issueCounts | ConvertTo-Json -Depth 10)"

          # Inspect the properties of the issueCounts object
          Write-Host "Properties of ISSUE_COUNTS:"
          $issueCounts | Get-Member

          # Verify the keys in the hashtable
          Write-Host "Keys in ISSUE_COUNTS: $($issueCounts.Keys -join ', ')"

          # Collect all assignees using a Hashtable
          $assignees = @{}
          foreach ($column in $issueCounts.PSObject.Properties.Name) {
            Write-Host "Processing column: $column"  # Debugging: Output the column being processed
            foreach ($assignee in $issueCounts.$column.PSObject.Properties.Name) {
              Write-Host "Processing assignee: $assignee"  # Debugging: Output the assignee being processed
              if (-not $assignees.ContainsKey($assignee)) {
                $assignees[$assignee] = @{}
                Write-Host "Added new assignee: $assignee"  # Debugging: Output when a new assignee is added
              }
              $assignees[$assignee][$column] = $issueCounts.$column.$assignee
              Write-Host "Added $assignee to $column with count $($issueCounts.$column.$assignee)"  # Debugging: Output the added data
            }
          }

          # Debugging: Output the assignees data
          Write-Host "Assignees Data: $($assignees | ConvertTo-Json -Depth 10)"

          # Define the desired column order
          $columns = @("Todo", "In Progress", "testing", "Done")

          # Set a fixed length for each cell
          $cellLength = 25

          # Generate the table header
          $header = "Assignee".PadRight($cellLength) + " | " + ($columns | ForEach-Object { $_.PadRight($cellLength) }) -join " | "
          $separator = ("-" * $cellLength) + "-|" + ($columns | ForEach-Object { "-" * $cellLength }) -join "-|"
          $table = "$header`n$separator`n"

          # Debugging: Output the table header and separator
          Write-Host "Table Header: $header"
          Write-Host "Table Separator: $separator"

          # Generate the table rows
          foreach ($assignee in $assignees.Keys) {
            $row = $assignee.PadRight($cellLength) + " | "
            foreach ($column in $columns) {
              $count = if ($assignees[$assignee].ContainsKey($column)) { $assignees[$assignee][$column] } else { 0 }
              $row += $count.ToString().PadRight($cellLength) + " | "
            }
            $table += "$row`n"
            Write-Host "Table Row: $row"  # Debugging: Output each table row
          }

          Write-Host "ASCII Table:`n$table"